/**
 * Resume DOCX Generator
 * Converts ResumeData to .docx format using the docx library
 * Follows ATS-friendly formatting guidelines
 */

import { Document, Paragraph, TextRun, HeadingLevel, AlignmentType, BorderStyle, WidthType, Table, TableCell, TableRow, SectionType, UnderlineType, ShadingType, Packer } from 'docx';
import type { ResumeData, ExportOptions, TemplateStyle } from './types';
import { getTemplateById } from './templates';
import { formatDateRange as formatDateRangeUtil } from './utils/date-formatter';
import { getBulletCharacter, getBulletColor } from './utils/bullet-styles';
import { getEffectiveFont, getEffectiveFontSize, getSectionSpacing, getDocxFontFromFamily } from './utils/font-helpers';

/**
 * Generate a DOCX document from resume data
 */
export async function generateDocx(resumeData: ResumeData, options?: ExportOptions): Promise<Blob> {
  // Get template style
  const template = getTemplateById(resumeData.templateId);
  const templateStyle = template?.style || getDefaultStyle();
  
  // Create effective style with user font overrides
  const style: TemplateStyle = {
    ...templateStyle,
    // Override with user font settings if they exist and useTemplateFonts is false
    headerFont: getEffectiveFont(resumeData, templateStyle, 'header'),
    bodyFont: getEffectiveFont(resumeData, templateStyle, 'body'),
    contactFont: getEffectiveFont(resumeData, templateStyle, 'contact'),
    headerFontSize: getEffectiveFontSize(resumeData, templateStyle, 'header'),
    bodyFontSize: getEffectiveFontSize(resumeData, templateStyle, 'body'),
    contactFontSize: getEffectiveFontSize(resumeData, templateStyle, 'contact'),
    sectionSpacing: getSectionSpacing(resumeData, templateStyle),
  };
  const doc = new Document({
    creator: 'Quest Bot Resume Builder',
    title: resumeData.title || 'Resume',
    description: `Resume generated by Quest Bot`,
    sections: [
      {
        properties: {
          page: {
            size: {
              orientation: 'portrait',
              width: 12240, // 8.5 inches in twentieths of a point
              height: 15840, // 11 inches
            },
            margin: {
              top: 1440, // 1 inch
              right: 1440,
              bottom: 1440,
              left: 1440,
            },
          },
        },
        children: style.layoutType && style.layoutType !== 'single-column'
          ? [
              ...generateHeader(resumeData.personalInfo, style, resumeData),
              ...generateColumnLayout(resumeData, style),
            ]
          : [
            // Header: Personal Information
            ...generateHeader(resumeData.personalInfo, style, resumeData),
            
            // Summary Section
            ...(resumeData.summary ? generateSummary(resumeData.summary, style) : []),
            
            // Work Experience
            ...(resumeData.experience.length > 0 ? generateExperienceSection(resumeData.experience, style) : []),
            
            // Education
            ...(resumeData.education.length > 0 ? generateEducationSection(resumeData.education, style) : []),
            
            // Skills
            ...(resumeData.skills.length > 0 ? generateSkillsSection(resumeData.skills, style) : []),
            
            // Certifications
            ...(resumeData.certifications && resumeData.certifications.length > 0 
              ? generateCertificationsSection(resumeData.certifications, style) 
              : []),
            
            // Projects
            ...(resumeData.projects && resumeData.projects.length > 0 
              ? generateProjectsSection(resumeData.projects, style) 
              : []),
            
            // Languages
            ...(resumeData.languages && resumeData.languages.length > 0 
              ? generateLanguagesSection(resumeData.languages, style) 
              : []),
            
            // Custom Sections
            ...(resumeData.customSections && resumeData.customSections.length > 0 
              ? generateCustomSections(resumeData.customSections, style) 
              : []),
          ],
      },
    ],
  });

  try {
    // Try toBlob first (available in newer versions)
    if (typeof Packer.toBlob === 'function') {
      return await Packer.toBlob(doc);
    }
    // Fallback to base64 string and convert to blob
    const base64 = await Packer.toBase64String(doc);
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], {
      type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    });
  } catch (error) {
    console.error('Error generating DOCX:', error);
    throw new Error(`Failed to generate DOCX: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Get default style fallback
 */
function getDefaultStyle(): TemplateStyle {
  return {
    primaryColor: '#000000',
    secondaryColor: '#4b5563',
    dividerColor: '#e5e7eb',
    textColor: '#000000',
    backgroundColor: '#ffffff',
    headerFont: 'Arial',
    bodyFont: 'Arial',
    contactFont: 'Arial',
    docxHeaderFont: 'Arial',
    docxBodyFont: 'Arial',
    docxContactFont: 'Arial',
    headerFontSize: 32,
    bodyFontSize: 22,
    contactFontSize: 20,
    headerFontWeight: 'bold',
    headerAlignment: 'center',
    contentAlignment: 'left',
    sectionSpacing: 240,
    headerStyle: 'plain',
    dividerStyle: 'line',
    showAccentBars: false,
  };
}

/**
 * Convert alignment string to AlignmentType
 */
function getAlignment(alignment: string): AlignmentType {
  switch (alignment) {
    case 'left': return AlignmentType.LEFT;
    case 'center': return AlignmentType.CENTER;
    case 'right': return AlignmentType.RIGHT;
    case 'justified': return AlignmentType.JUSTIFIED;
    default: return AlignmentType.LEFT;
  }
}

/**
 * Convert hex color to docx format (remove # if present)
 */
function formatColor(hex: string): string {
  return hex.replace('#', '');
}

/**
 * Generate header section with personal information
 */
function generateHeader(personalInfo: ResumeData['personalInfo'], style: TemplateStyle, resumeData?: ResumeData): (Paragraph | Table)[] {
  const effectiveStyle = resumeData ? {
    ...style,
    headerFont: getEffectiveFont(resumeData, style, 'header'),
    bodyFont: getEffectiveFont(resumeData, style, 'body'),
    contactFont: getEffectiveFont(resumeData, style, 'contact'),
    headerFontSize: getEffectiveFontSize(resumeData, style, 'header'),
    bodyFontSize: getEffectiveFontSize(resumeData, style, 'body'),
    contactFontSize: getEffectiveFontSize(resumeData, style, 'contact'),
  } : style;
  const content: (Paragraph | Table)[] = [];
  
  // Handle two-column header layout (T2: Professional Navy)
  if (style.layoutType === 'two-column-header') {
    const nameCell = new TableCell({
      children: [
        new Paragraph({
          children: [
            new TextRun({
              text: personalInfo.fullName.toUpperCase(),
              bold: effectiveStyle.headerFontWeight !== 'normal',
              size: resumeData ? getEffectiveFontSize(resumeData, style, 'name') : effectiveStyle.headerFontSize,
              color: formatColor(style.primaryColor),
              font: effectiveStyle.docxHeaderFont || getDocxFontFromFamily(effectiveStyle.headerFont),
            }),
          ],
          alignment: AlignmentType.LEFT,
          spacing: { after: 60 },
        }),
        ...(personalInfo.title ? [new Paragraph({
          children: [
            new TextRun({
              text: personalInfo.title,
              italics: true,
              size: effectiveStyle.bodyFontSize,
              color: formatColor(style.textColor),
              font: effectiveStyle.docxBodyFont || getDocxFontFromFamily(effectiveStyle.bodyFont),
            }),
          ],
          alignment: AlignmentType.LEFT,
          spacing: { after: 60 },
        })] : []),
      ],
      width: { size: (style.leftColumnWidth || 60) / 100 * 5000, type: WidthType.DXA },
    });
    
    const contactParts: string[] = [];
    if (personalInfo.email) contactParts.push(personalInfo.email);
    if (personalInfo.phone) contactParts.push(personalInfo.phone);
    if (personalInfo.linkedin) contactParts.push(`LinkedIn: ${personalInfo.linkedin}`);
    if (personalInfo.github) contactParts.push(`GitHub: ${personalInfo.github}`);
    if (personalInfo.website) contactParts.push(personalInfo.website);
    if (personalInfo.address) contactParts.push(personalInfo.address);
    
    const contactCell = new TableCell({
      children: contactParts.length > 0 ? [new Paragraph({
        children: [
          new TextRun({
            text: contactParts.join(' | '),
            size: style.contactFontSize,
            color: formatColor(style.textColor),
            font: style.docxContactFont || getDocxFontFromFamily(style.contactFont),
          }),
        ],
        alignment: AlignmentType.RIGHT,
      })] : [],
      width: { size: (style.rightColumnWidth || 40) / 100 * 5000, type: WidthType.DXA },
    });
    
    const headerTable = new Table({
      rows: [new TableRow({ children: [nameCell, contactCell] })],
      width: { size: 100, type: WidthType.PERCENTAGE },
    });
    
    content.push(headerTable);
    
    // Add underline if needed
    if (style.headerStyle === 'underline') {
      content.push(
        new Paragraph({
          children: [new TextRun({ text: '' })],
          spacing: { after: 60 },
          border: {
            bottom: {
              color: formatColor(style.primaryColor),
              size: 2,
              style: BorderStyle.SINGLE,
            },
          },
        })
      );
    }
    
    return content;
  }
  
  // Standard single-column header
  // Full Name - Large and bold with template styling
  content.push(
    new Paragraph({
      children: [
        new TextRun({
          text: personalInfo.fullName.toUpperCase(),
          bold: effectiveStyle.headerFontWeight !== 'normal',
          size: resumeData ? getEffectiveFontSize(resumeData, style, 'name') : effectiveStyle.headerFontSize,
          color: formatColor(style.primaryColor),
          font: effectiveStyle.docxHeaderFont || getDocxFontFromFamily(effectiveStyle.headerFont),
        }),
      ],
      alignment: getAlignment(style.headerAlignment),
      spacing: { after: 120 },
    })
  );
  
  // Title - Smaller and italic
  if (personalInfo.title) {
    content.push(
      new Paragraph({
        children: [
          new TextRun({
            text: personalInfo.title,
            italics: true,
            size: style.bodyFontSize,
            color: formatColor(style.textColor),
            font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
          }),
        ],
        alignment: getAlignment(style.headerAlignment),
        spacing: { after: 120 },
      })
    );
  }
  
  // Contact Information - Single line separated by pipes
  const contactParts: string[] = [];
  if (personalInfo.email) contactParts.push(personalInfo.email);
  if (personalInfo.phone) contactParts.push(personalInfo.phone);
  if (personalInfo.linkedin) contactParts.push(`LinkedIn: ${personalInfo.linkedin}`);
  if (personalInfo.github) contactParts.push(`GitHub: ${personalInfo.github}`);
  if (personalInfo.website) contactParts.push(personalInfo.website);
  if (personalInfo.address) contactParts.push(personalInfo.address);
  
  if (contactParts.length > 0) {
    content.push(
      new Paragraph({
        children: [
          new TextRun({
            text: contactParts.join(' | '),
            size: style.contactFontSize,
            color: formatColor(style.textColor),
            font: style.docxContactFont || getDocxFontFromFamily(style.contactFont),
          }),
        ],
        alignment: getAlignment(style.headerAlignment),
        spacing: { after: 240 },
      })
    );
  }
  
  // Add accent bar or underline if needed
  if (style.headerStyle === 'background' && style.showAccentBars) {
    content.push(
      new Paragraph({
        children: [
          new TextRun({
            text: '',
          }),
        ],
        spacing: { after: 60 },
        border: {
          bottom: {
            color: formatColor(style.secondaryColor),
            size: 6,
            style: BorderStyle.SINGLE,
          },
        },
      })
    );
  } else if (style.headerStyle === 'underline') {
    content.push(
      new Paragraph({
        children: [
          new TextRun({
            text: '',
          }),
        ],
        spacing: { after: 60 },
        border: {
          bottom: {
            color: formatColor(style.primaryColor),
            size: 2,
            style: BorderStyle.SINGLE,
          },
        },
      })
    );
  }
  
  return content;
}

/**
 * Generate professional summary section
 */
function generateSummary(summary: string, style: TemplateStyle): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'SUMMARY',
          bold: style.headerFontWeight !== 'normal',
          size: style.bodyFontSize,
          color: formatColor(style.primaryColor),
          font: style.docxHeaderFont || getDocxFontFromFamily(style.headerFont),
        }),
      ],
      spacing: { after: 120 },
      border: style.dividerStyle === 'line' ? {
        bottom: {
          color: formatColor(style.dividerColor),
          size: 1,
          style: BorderStyle.SINGLE,
        },
      } : undefined,
    })
  );
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: summary,
          size: style.bodyFontSize,
          color: formatColor(style.textColor),
          font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
        }),
      ],
      alignment: getAlignment(style.contentAlignment),
      spacing: { after: style.sectionSpacing },
    })
  );
  
  return paragraphs;
}

/**
 * Generate work experience section
 */
function generateExperienceSection(experience: ResumeData['experience'], style: TemplateStyle): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'EXPERIENCE',
          bold: style.headerFontWeight !== 'normal',
          size: style.bodyFontSize,
          color: formatColor(style.primaryColor),
          font: style.docxHeaderFont || getDocxFontFromFamily(style.headerFont),
        }),
      ],
      spacing: { after: 120 },
      border: style.dividerStyle === 'line' || style.dividerStyle === 'dotted' ? {
        bottom: {
          color: formatColor(style.dividerColor),
          size: style.dividerStyle === 'dotted' ? 1 : 1,
          style: style.dividerStyle === 'dotted' ? BorderStyle.DOTTED : BorderStyle.SINGLE,
        },
      } : undefined,
    })
  );
  
  experience.forEach((exp, index) => {
    // Job Title | Company | Location | Dates
    const headerLine = [
      exp.jobTitle,
      exp.company,
      exp.location,
      formatDateRange(exp.startDate, exp.endDate, style)
    ].filter(Boolean).join(' | ');
    
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: headerLine,
            bold: style.headerFontWeight !== 'normal',
            size: style.bodyFontSize,
            color: formatColor(style.textColor),
            font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
          }),
        ],
        spacing: { after: 60 },
      })
    );
    
    // Achievements
    exp.achievements.forEach((achievement) => {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${getBulletCharacter(style)} ${achievement}`,
              size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
            }),
          ],
          spacing: { after: 40 },
          indent: { left: 360 }, // Indent bullet points
        })
      );
    });
    
    // Technologies (if present)
    if (exp.technologies && exp.technologies.length > 0) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `Technologies: ${exp.technologies.join(', ')}`,
              italics: true,
              size: style.contactFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
            }),
          ],
          spacing: { after: 40 },
          indent: { left: 360 },
        })
      );
    }
    
    // Spacing between jobs
    if (index < experience.length - 1) {
      paragraphs.push(
        new Paragraph({
          spacing: { after: 120 },
        })
      );
    }
  });
  
  paragraphs.push(
    new Paragraph({
      spacing: { after: style.sectionSpacing },
    })
  );
  
  return paragraphs;
}

/**
 * Generate education section
 */
function generateEducationSection(education: ResumeData['education'], style: TemplateStyle): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'EDUCATION',
          bold: style.headerFontWeight !== 'normal',
          size: style.bodyFontSize,
          color: formatColor(style.primaryColor),
          font: style.docxHeaderFont || getDocxFontFromFamily(style.headerFont),
        }),
      ],
      spacing: { after: 120 },
      border: style.dividerStyle === 'line' || style.dividerStyle === 'dotted' ? {
        bottom: {
          color: formatColor(style.dividerColor),
          size: 1,
          style: style.dividerStyle === 'dotted' ? BorderStyle.DOTTED : BorderStyle.SINGLE,
        },
      } : undefined,
    })
  );
  
  education.forEach((edu, index) => {
    const headerLine = [
      edu.degree,
      edu.institution,
      edu.location,
      edu.graduationDate
    ].filter(Boolean).join(' | ');
    
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: headerLine,
            bold: style.headerFontWeight !== 'normal',
            size: style.bodyFontSize,
            color: formatColor(style.textColor),
            font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
          }),
        ],
        spacing: { after: 60 },
      })
    );
    
    // GPA
    if (edu.gpa) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `GPA: ${edu.gpa}`,
              size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
            }),
          ],
          spacing: { after: 40 },
          indent: { left: 360 },
        })
      );
    }
    
    // Coursework
    if (edu.coursework && edu.coursework.length > 0) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `Relevant Coursework: ${edu.coursework.join(', ')}`,
              size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
            }),
          ],
          spacing: { after: 40 },
          indent: { left: 360 },
        })
      );
    }
    
    // Honors
    if (edu.honors && edu.honors.length > 0) {
      edu.honors.forEach((honor) => {
        paragraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `${getBulletCharacter(style)} ${honor}`,
                size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
            }),
            ],
            spacing: { after: 40 },
            indent: { left: 360 },
          })
        );
      });
    }
    
    if (index < education.length - 1) {
      paragraphs.push(
        new Paragraph({
          spacing: { after: 120 },
        })
      );
    }
  });
  
  paragraphs.push(
    new Paragraph({
      spacing: { after: 240 },
    })
  );
  
  return paragraphs;
}

/**
 * Generate skills section
 */
function generateSkillsSection(skills: ResumeData['skills'], style: TemplateStyle): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'SKILLS',
          bold: true,
          size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
        }),
      ],
      spacing: { after: 120 },
    })
  );
  
  // Group skills by category
  const skillsByCategory = new Map<string, string[]>();
  skills.forEach(skill => {
    const category = skill.category || 'Other';
    if (!skillsByCategory.has(category)) {
      skillsByCategory.set(category, []);
    }
    skillsByCategory.get(category)!.push(skill.name);
  });
  
  // Format each category
  skillsByCategory.forEach((skillNames, category) => {
    const line = `${category}: ${skillNames.join(', ')}`;
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: line,
            size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
          }),
        ],
        spacing: { after: 60 },
      })
    );
  });
  
  paragraphs.push(
    new Paragraph({
      spacing: { after: 240 },
    })
  );
  
  return paragraphs;
}

/**
 * Generate certifications section
 */
function generateCertificationsSection(certifications: ResumeData['certifications'], style: TemplateStyle): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'CERTIFICATIONS',
          bold: true,
          size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
        }),
      ],
      spacing: { after: 120 },
    })
  );
  
  certifications!.forEach((cert) => {
    const certLine = [
      `${getBulletCharacter(style)} ${cert.name}`,
      cert.issuer,
      cert.date
    ].filter(Boolean).join(' | ');
    
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: certLine,
            size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
          }),
        ],
        spacing: { after: 60 },
      })
    );
  });
  
  paragraphs.push(
    new Paragraph({
      spacing: { after: 240 },
    })
  );
  
  return paragraphs;
}

/**
 * Generate projects section
 */
function generateProjectsSection(projects: ResumeData['projects'], style: TemplateStyle): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'PROJECTS',
          bold: true,
          size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
        }),
      ],
      spacing: { after: 120 },
    })
  );
  
  projects!.forEach((project, index) => {
    const headerParts = [project.title];
    if (project.organization) headerParts.push(project.organization);
    if (project.startDate || project.endDate) {
      headerParts.push(formatDateRange(project.startDate, project.endDate, style));
    }
    
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: headerParts.join(' | '),
            bold: true,
            size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
          }),
        ],
        spacing: { after: 60 },
      })
    );
    
    // Description
    project.description.forEach((desc) => {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${getBulletCharacter(style)} ${desc}`,
              size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
            }),
          ],
          spacing: { after: 40 },
          indent: { left: 360 },
        })
      );
    });
    
    // Technologies
    if (project.technologies && project.technologies.length > 0) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `Technologies: ${project.technologies.join(', ')}`,
              italics: true,
              size: 20,
            }),
          ],
          spacing: { after: 40 },
          indent: { left: 360 },
        })
      );
    }
    
    // URL
    if (project.url) {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: project.url,
              size: 20,
              color: '0066cc',
            }),
          ],
          spacing: { after: 40 },
          indent: { left: 360 },
        })
      );
    }
    
    if (index < projects!.length - 1) {
      paragraphs.push(
        new Paragraph({
          spacing: { after: 120 },
        })
      );
    }
  });
  
  paragraphs.push(
    new Paragraph({
      spacing: { after: 240 },
    })
  );
  
  return paragraphs;
}

/**
 * Generate languages section
 */
function generateLanguagesSection(languages: ResumeData['languages'], style: TemplateStyle): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'LANGUAGES',
          bold: true,
          size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
        }),
      ],
      spacing: { after: 120 },
    })
  );
  
  languages!.forEach((lang) => {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: `${getBulletCharacter(style)} ${lang.name} - ${lang.proficiency}`,
            size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
          }),
        ],
        spacing: { after: 60 },
      })
    );
  });
  
  paragraphs.push(
    new Paragraph({
      spacing: { after: 240 },
    })
  );
  
  return paragraphs;
}

/**
 * Generate custom sections
 */
function generateCustomSections(customSections: ResumeData['customSections'], style: TemplateStyle): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  customSections!.forEach((section) => {
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: section.title.toUpperCase(),
            bold: true,
            size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
          }),
        ],
        spacing: { after: 120 },
      })
    );
    
    section.content.forEach((line) => {
      paragraphs.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${getBulletCharacter(style)} ${line}`,
              size: style.bodyFontSize,
              color: formatColor(style.textColor),
              font: style.docxBodyFont || style.bodyFont.split(",")[0].trim(),
            }),
          ],
          spacing: { after: 60 },
        })
      );
    });
    
    paragraphs.push(
      new Paragraph({
        spacing: { after: 240 },
      })
    );
  });
  
  return paragraphs;
}

/**
 * Generate column layout content using Word tables (ATS-friendly)
 */
function generateColumnLayout(resumeData: ResumeData, style: TemplateStyle): (Paragraph | Table)[] {
  const content: (Paragraph | Table)[] = [];
  const layoutType = style.layoutType || 'single-column';
  
  if (layoutType === 'two-column-sidebar') {
    // M2: Creative Bold - Left sidebar (30%) with skills/languages, Right main (70%) with rest
    const sidebarContent: Paragraph[] = [];
    const mainContent: Paragraph[] = [];
    
    // Sidebar: Skills and Languages
    if (resumeData.skills.length > 0) {
      sidebarContent.push(...generateSkillsSection(resumeData.skills, style));
    }
    if (resumeData.languages && resumeData.languages.length > 0) {
      sidebarContent.push(...generateLanguagesSection(resumeData.languages, style));
    }
    
    // Main: Summary, Experience, Education, Projects, Certifications
    if (resumeData.summary) {
      mainContent.push(...generateSummary(resumeData.summary, style));
    }
    if (resumeData.experience.length > 0) {
      mainContent.push(...generateExperienceSection(resumeData.experience, style));
    }
    if (resumeData.education.length > 0) {
      mainContent.push(...generateEducationSection(resumeData.education, style));
    }
    if (resumeData.projects && resumeData.projects.length > 0) {
      mainContent.push(...generateProjectsSection(resumeData.projects, style));
    }
    if (resumeData.certifications && resumeData.certifications.length > 0) {
      mainContent.push(...generateCertificationsSection(resumeData.certifications, style));
    }
    
    // Create two-column table
    const leftWidth = style.leftColumnWidth || 30;
    const rightWidth = style.rightColumnWidth || 70;
    
    content.push(createTwoColumnTable(sidebarContent, mainContent, leftWidth, rightWidth, style));
    
  } else if (layoutType === 'three-column') {
    // M3: Sleek Dark - Three columns (25%, 50%, 25%)
    const leftCol: Paragraph[] = [];
    const middleCol: Paragraph[] = [];
    const rightCol: Paragraph[] = [];
    
    // Left: Contact info (condensed), Core skills
    if (resumeData.skills.length > 0) {
      leftCol.push(...generateSkillsSection(resumeData.skills, style));
    }
    
    // Middle: Experience, Education (main content)
    if (resumeData.experience.length > 0) {
      middleCol.push(...generateExperienceSection(resumeData.experience, style));
    }
    if (resumeData.education.length > 0) {
      middleCol.push(...generateEducationSection(resumeData.education, style));
    }
    if (resumeData.summary) {
      middleCol.push(...generateSummary(resumeData.summary, style));
    }
    
    // Right: Certifications, Languages, Additional skills
    if (resumeData.certifications && resumeData.certifications.length > 0) {
      rightCol.push(...generateCertificationsSection(resumeData.certifications, style));
    }
    if (resumeData.languages && resumeData.languages.length > 0) {
      rightCol.push(...generateLanguagesSection(resumeData.languages, style));
    }
    if (resumeData.projects && resumeData.projects.length > 0) {
      rightCol.push(...generateProjectsSection(resumeData.projects, style));
    }
    
    content.push(createThreeColumnTable(leftCol, middleCol, rightCol, style));
    
  } else if (layoutType === 'two-column-header') {
    // T2: Professional Navy - Two-column header layout
    // For header, we'll handle it specially in generateHeader
    // Then use regular single-column for rest
    if (resumeData.summary) {
      content.push(...generateSummary(resumeData.summary, style));
    }
    if (resumeData.experience.length > 0) {
      content.push(...generateExperienceSection(resumeData.experience, style));
    }
    if (resumeData.education.length > 0) {
      content.push(...generateEducationSection(resumeData.education, style));
    }
    if (resumeData.skills.length > 0) {
      content.push(...generateSkillsSection(resumeData.skills, style));
    }
    if (resumeData.certifications && resumeData.certifications.length > 0) {
      content.push(...generateCertificationsSection(resumeData.certifications, style));
    }
    if (resumeData.projects && resumeData.projects.length > 0) {
      content.push(...generateProjectsSection(resumeData.projects, style));
    }
    if (resumeData.languages && resumeData.languages.length > 0) {
      content.push(...generateLanguagesSection(resumeData.languages, style));
    }
    
  } else if (layoutType === 'two-column') {
    // P2: Executive Gray - Two-column skills layout
    // Regular flow but skills in two columns
    if (resumeData.summary) {
      content.push(...generateSummary(resumeData.summary, style));
    }
    if (resumeData.skills.length > 0) {
      content.push(...generateSkillsSectionTwoColumn(resumeData.skills, style));
    }
    if (resumeData.experience.length > 0) {
      content.push(...generateExperienceSection(resumeData.experience, style));
    }
    if (resumeData.education.length > 0) {
      content.push(...generateEducationSection(resumeData.education, style));
    }
    if (resumeData.certifications && resumeData.certifications.length > 0) {
      content.push(...generateCertificationsSection(resumeData.certifications, style));
    }
    if (resumeData.languages && resumeData.languages.length > 0) {
      content.push(...generateLanguagesSection(resumeData.languages, style));
    }
  }
  
  return content;
}

/**
 * Create a two-column table for sidebar layout
 */
function createTwoColumnTable(leftContent: Paragraph[], rightContent: Paragraph[], leftWidth: number, rightWidth: number, style: TemplateStyle): Table {
  const leftPercent = (leftWidth / 100) * 5000; // Convert to twentieths of a point
  const rightPercent = (rightWidth / 100) * 5000;
  
  // Combine all content into cells
  const leftCell = new TableCell({
    children: leftContent,
    width: { size: leftPercent, type: WidthType.DXA },
    margins: { top: 400, bottom: 400, left: 200, right: 400 },
  });
  
  const rightCell = new TableCell({
    children: rightContent,
    width: { size: rightPercent, type: WidthType.DXA },
    margins: { top: 400, bottom: 400, left: 400, right: 200 },
  });
  
  return new Table({
    rows: [new TableRow({ children: [leftCell, rightCell] })],
    width: { size: 100, type: WidthType.PERCENTAGE },
  });
}

/**
 * Create a three-column table
 */
function createThreeColumnTable(leftCol: Paragraph[], middleCol: Paragraph[], rightCol: Paragraph[], style: TemplateStyle): Table {
  const leftWidth = style.leftColumnWidth || 25;
  const middleWidth = style.middleColumnWidth || 50;
  const rightWidth = style.rightColumnWidth || 25;
  
  const leftPercent = (leftWidth / 100) * 5000;
  const middlePercent = (middleWidth / 100) * 5000;
  const rightPercent = (rightWidth / 100) * 5000;
  
  const leftCell = new TableCell({
    children: leftCol,
    width: { size: leftPercent, type: WidthType.DXA },
    margins: { top: 400, bottom: 400, left: 200, right: 300 },
  });
  
  const middleCell = new TableCell({
    children: middleCol,
    width: { size: middlePercent, type: WidthType.DXA },
    margins: { top: 400, bottom: 400, left: 300, right: 300 },
  });
  
  const rightCell = new TableCell({
    children: rightCol,
    width: { size: rightPercent, type: WidthType.DXA },
    margins: { top: 400, bottom: 400, left: 300, right: 200 },
  });
  
  return new Table({
    rows: [new TableRow({ children: [leftCell, middleCell, rightCell] })],
    width: { size: 100, type: WidthType.PERCENTAGE },
  });
}

/**
 * Generate skills section in two columns
 */
function generateSkillsSectionTwoColumn(skills: ResumeData['skills'], style: TemplateStyle): (Paragraph | Table)[] {
  const paragraphs: (Paragraph | Table)[] = [];
  
  // Section header (full width)
  paragraphs.push(
    new Paragraph({
      children: [
        new TextRun({
          text: 'SKILLS',
          bold: style.headerFontWeight !== 'normal',
          size: style.bodyFontSize,
          color: formatColor(style.primaryColor),
          font: style.docxHeaderFont || getDocxFontFromFamily(style.headerFont),
        }),
      ],
      spacing: { after: 120 },
      border: style.dividerStyle === 'line' || style.dividerStyle === 'dotted' ? {
        bottom: {
          color: formatColor(style.dividerColor),
          size: 1,
          style: style.dividerStyle === 'dotted' ? BorderStyle.DOTTED : BorderStyle.SINGLE,
        },
      } : undefined,
    })
  );
  
  // Split skills into two columns
  const midpoint = Math.ceil(skills.length / 2);
  const leftSkills = skills.slice(0, midpoint);
  const rightSkills = skills.slice(midpoint);
  
  const leftParagraphs: Paragraph[] = [];
  const rightParagraphs: Paragraph[] = [];
  
  // Group skills by category for left
  const leftByCategory = new Map<string, string[]>();
  leftSkills.forEach(skill => {
    const category = skill.category || 'Other';
    if (!leftByCategory.has(category)) {
      leftByCategory.set(category, []);
    }
    leftByCategory.get(category)!.push(skill.name);
  });
  
  leftByCategory.forEach((skillNames, category) => {
    const line = `${category}: ${skillNames.join(', ')}`;
    leftParagraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: line,
            size: style.bodyFontSize,
            color: formatColor(style.textColor),
            font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
          }),
        ],
        spacing: { after: 60 },
      })
    );
  });
  
  // Group skills by category for right
  const rightByCategory = new Map<string, string[]>();
  rightSkills.forEach(skill => {
    const category = skill.category || 'Other';
    if (!rightByCategory.has(category)) {
      rightByCategory.set(category, []);
    }
    rightByCategory.get(category)!.push(skill.name);
  });
  
  rightByCategory.forEach((skillNames, category) => {
    const line = `${category}: ${skillNames.join(', ')}`;
    rightParagraphs.push(
      new Paragraph({
        children: [
          new TextRun({
            text: line,
            size: style.bodyFontSize,
            color: formatColor(style.textColor),
            font: style.docxBodyFont || getDocxFontFromFamily(style.bodyFont),
          }),
        ],
        spacing: { after: 60 },
      })
    );
  });
  
  // Create two-column table for skills
  paragraphs.push(createTwoColumnTable(leftParagraphs, rightParagraphs, 50, 50, style));
  
  paragraphs.push(
    new Paragraph({
      spacing: { after: style.sectionSpacing },
    })
  );
  
  return paragraphs;
}

/**
 * Format date range for display
 */
function formatDateRange(start: string | undefined, end: string | null | undefined, style: TemplateStyle): string {
  if (!start) return '';
  return formatDateRangeUtil(start, end || null, style);
}

/**
 * Helper function to download DOCX file (client-side)
 */
export async function downloadDocx(resumeData: ResumeData, filename: string): Promise<void> {
  try {
    if (typeof document === 'undefined') {
      throw new Error('downloadDocx can only be called in a browser environment');
    }
    
    console.log('Generating DOCX blob for:', filename);
    const blob = await generateDocx(resumeData);
    
    if (!blob || blob.size === 0) {
      throw new Error('Generated DOCX blob is empty');
    }
    
    console.log('Blob created:', { size: blob.size, type: blob.type });
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename.endsWith('.docx') ? filename : `${filename}.docx`;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    
    // Cleanup after a short delay
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      console.log('Download complete and cleaned up');
    }, 100);
  } catch (error) {
    console.error('Download error:', error);
    throw error;
  }
}

